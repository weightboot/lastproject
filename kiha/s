-- 폴리곤 테이블 생성 --

-- polygon 테이블--
CREATE TABLE polygon (
    id INT generated always as identity PRIMARY KEY,
    P_high DOUBLE PRECISION,
    P_hscore INT,
    P_slant varchar(10),
    P_sscore int,
    P_CVdist DOUBLE PRECISION,
    P_CVscore int,
    P_Ddist DOUBLE PRECISION,
    P_Dscore INT,
    P_price DOUBLE PRECISION,
    P_pscore INT,
    P_Rdist DOUBLE PRECISION,
    P_Rscore INT,
    P_Arate DOUBLE PRECISION,
    P_Ascore INT,
    P_Erate DOUBLE PRECISION,
    P_Escore INT,
    P_RGArate DOUBLE PRECISION,
    P_RGAscore INT,
    P_RGdist double precision,
    P_RGDscore INT,
    P_FMdist double precision,
    P_FMscore INT,
    P_Seadist double precision,
    P_Seascore INT,
    DV_SumScore INT,
    CS_sumscore INT,
    T_score INT,
    normalized_score DOUBLE PRECISION,
    grade VARCHAR(2)
);






///////////////////////grade 테이블 생성
-- grade 테이블 생성
DROP TABLE IF EXISTS grade CASCADE;
CREATE TABLE grade (
    id INT PRIMARY KEY,
    pnu VARCHAR(20),
    dv_sumscore INT,
    cs_sumscore INT,
    T_score INT,
    normalized_score DOUBLE PRECISION,
    grade VARCHAR(2)
);

-- 데이터 초기 삽입
INSERT INTO grade (id, pnu, dv_sumscore, cs_sumscore, T_score)
SELECT 
    dv.id,
    dv.pnu,
    dv.DV_SumScore AS dv_sumscore,
    cs.CS_sumscore AS cs_sumscore,
    dv.DV_SumScore - cs.CS_sumscore AS T_score
FROM 
    Development_Suitability dv
JOIN 
    Conservation_Suitability cs ON dv.pnu = cs.pnu
ORDER BY 
    dv.pnu;

-- 최소값과 최대값 계산
DO $$ 
DECLARE
    min_T_score INT;
    max_T_score INT;
BEGIN
    SELECT MIN(T_score), MAX(T_score) INTO min_T_score, max_T_score FROM grade;

    -- normalized_score 및 grade 업데이트
    UPDATE grade
    SET normalized_score = ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3),
        grade = CASE
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.2 THEN '가'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.4 THEN '나'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.6 THEN '다'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.8 THEN '라'
            ELSE '마'
        END;
END $$;

-- update_grade 함수 생성
CREATE OR REPLACE FUNCTION update_grade()
RETURNS TRIGGER AS $$
DECLARE
    min_T_score INT;
    max_T_score INT;
BEGIN
    -- grade 테이블 업데이트
    UPDATE grade
    SET 
        dv_sumscore = (SELECT DV_SumScore FROM Development_Suitability WHERE pnu = NEW.pnu),
        cs_sumscore = (SELECT CS_sumscore FROM Conservation_Suitability WHERE pnu = NEW.pnu),
        T_score = (SELECT DV_SumScore FROM Development_Suitability WHERE pnu = NEW.pnu) - (SELECT CS_sumscore FROM Conservation_Suitability WHERE pnu = NEW.pnu)
    WHERE pnu = NEW.pnu;

    -- 최소값과 최대값 계산
    SELECT MIN(T_score), MAX(T_score) INTO min_T_score, max_T_score FROM grade;

    -- normalized_score 및 grade 업데이트
    UPDATE grade
    SET 
        normalized_score = ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3),
        grade = CASE
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.2 THEN '가'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.4 THEN '나'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.6 THEN '다'
            WHEN ROUND(CAST((T_score - min_T_score) AS NUMERIC) / (max_T_score - min_T_score), 3) < 0.8 THEN '라'
            ELSE '마'
        END
    WHERE pnu = NEW.pnu;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 트리거 생성
CREATE TRIGGER update_development_trigger
AFTER INSERT OR UPDATE ON Development_Suitability
FOR EACH ROW
EXECUTE FUNCTION update_grade();

CREATE TRIGGER update_conservation_trigger
AFTER INSERT OR UPDATE ON Conservation_Suitability
FOR EACH ROW
EXECUTE FUNCTION update_grade();
















////////////////// view 테이블 생성 



CREATE or replace VIEW Land_Evaluation_view AS
SELECT 
	info.id,
	info.pnu,
    FMarea.Arate,
    Ecorate.Erate,
    RGarea.RGArate,
    regulation.RGdist,
    farm.FMdist,
    Sea.Seadist,
    high.high,
    slant.slant,
    CV.CVdist,
    pricerate.price,
    road.Rdist,
	grade.DV_sumscore,
	grade.CS_sumscore,
	grade.T_score,
	grade.grade,
	info.geom
FROM 
    info
JOIN 
    FMarea ON info.pnu = FMarea.pnu
JOIN 
    Ecorate ON info.pnu = Ecorate.pnu
JOIN 
    RGarea ON info.pnu = RGarea.pnu
JOIN 
    regulation ON info.pnu = regulation.pnu
JOIN 
    farm ON info.pnu = farm.pnu
JOIN 
    Sea ON info.pnu = Sea.pnu
JOIN 
    high ON info.pnu = high.pnu
JOIN 
    slant ON info.pnu = slant.pnu
JOIN 
    CV ON info.pnu = CV.pnu
JOIN 
    pricerate ON info.pnu = pricerate.pnu
JOIN 
    road ON info.pnu = road.pnu
join
	grade on info.pnu = grade.pnu
order by pnu;





///// view테이블 속성 수정시 본판 테이블 수정 함수 및 트리거 생성
CREATE OR REPLACE FUNCTION update_land_evaluation_view()
RETURNS TRIGGER AS $$
BEGIN
    -- Update FMarea
    IF NEW.Arate IS DISTINCT FROM OLD.Arate THEN
        UPDATE FMarea
        SET Arate = NEW.Arate
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update Ecorate
    IF NEW.Erate IS DISTINCT FROM OLD.Erate THEN
        UPDATE Ecorate
        SET Erate = NEW.Erate
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update RGarea
    IF NEW.RGArate IS DISTINCT FROM OLD.RGArate THEN
        UPDATE RGarea
        SET RGArate = NEW.RGArate
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update regulation
    IF NEW.RGdist IS DISTINCT FROM OLD.RGdist THEN
        UPDATE regulation
        SET RGdist = NEW.RGdist
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update farm
    IF NEW.FMdist IS DISTINCT FROM OLD.FMdist THEN
        UPDATE farm
        SET FMdist = NEW.FMdist
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update Sea
    IF NEW.Seadist IS DISTINCT FROM OLD.Seadist THEN
        UPDATE Sea
        SET Seadist = NEW.Seadist
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update high
    IF NEW.high IS DISTINCT FROM OLD.high THEN
        UPDATE high
        SET high = NEW.high
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update slant
    IF NEW.slant IS DISTINCT FROM OLD.slant THEN
        UPDATE slant
        SET slant = NEW.slant
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update CV
    IF NEW.CVdist IS DISTINCT FROM OLD.CVdist THEN
        UPDATE CV
        SET CVdist = NEW.CVdist
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update pricerate
    IF NEW.price IS DISTINCT FROM OLD.price THEN
        UPDATE pricerate
        SET price = NEW.price
        WHERE pnu = NEW.pnu;
    END IF;
    
    -- Update road
    IF NEW.Rdist IS DISTINCT FROM OLD.Rdist THEN
        UPDATE road
        SET Rdist = NEW.Rdist
        WHERE pnu = NEW.pnu;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER instead_of_update_land_evaluation_view
INSTEAD OF UPDATE ON Land_Evaluation_view
FOR EACH ROW
EXECUTE FUNCTION update_land_evaluation_view();

update Land_Evaluation_view set high=500 where id=1;
